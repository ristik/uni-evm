//! Uni-EVM Guest Program for SP1 ZK Proving
//!
//! This crate provides a minimal guest program for proving uni-evm blocks using SP1 zkVM.
//! Unlike ethrex's guest program which outputs L2-specific fields, this outputs only the
//! two state roots needed for BFT-Core verification.
//!
//! ## Architecture
//!
//! - **Input**: `UniEvmProgramInput` (re-export of ethrex's `ProgramInput`)
//! - **Execution**: Wraps ethrex's `stateless_validation_l1` for block validation
//! - **Output**: `UniEvmProgramOutput` with exactly 64 bytes: [prev_state_root, new_state_root]
//!
//! ## Features
//!
//! - `sp1`: Enable SP1 backend (builds guest program, includes ELF binary)
//!
//! ## Usage
//!
//! ```ignore
//! use uni_evm_guest::{UNI_EVM_SP1_ELF, execution::uni_evm_execution};
//!
//! // The ELF is available when built with --features sp1
//! if !UNI_EVM_SP1_ELF.is_empty() {
//!     // Use ELF for SP1 proving
//! }
//! ```

pub mod execution;
pub mod input;
pub mod output;

// Re-exports for convenience
pub use execution::uni_evm_execution;
pub use input::UniEvmProgramInput;
pub use output::UniEvmProgramOutput;

/// SP1 zkVM guest program ELF binary
///
/// This is the compiled RISC-V ELF binary of the guest program that runs inside SP1 zkVM.
/// It is built during compilation when the `sp1` feature is enabled.
///
/// ## Build Process
///
/// 1. `build.rs` invokes `sp1-build` to compile `src/sp1/` to RISC-V
/// 2. ELF is written to `src/sp1/out/uni-evm-sp1-elf`
/// 3. `include_bytes!` embeds it in this constant
/// 4. Verification key is also generated to `src/sp1/out/uni-evm-vkey.bin`
///
/// ## Feature Gates
///
/// - **With `sp1` feature**: Points to the actual ELF binary (several MB)
/// - **Without `sp1` feature**: Empty slice (allows compilation without SP1 toolchain)
///
/// ## Usage
///
/// ```ignore
/// use sp1_sdk::{ProverClient, SP1Stdin};
///
/// let client = ProverClient::from_env();
/// let (pk, vk) = client.setup(UNI_EVM_SP1_ELF);
///
/// let mut stdin = SP1Stdin::new();
/// stdin.write(&input);
///
/// let proof = client.prove(&pk, &stdin, SP1ProofMode::Compressed)?;
/// ```
pub static UNI_EVM_SP1_ELF: &[u8] = {
    #[cfg(feature = "sp1")]
    {
        // Include the compiled SP1 guest program ELF
        // This file is generated by build.rs when building with --features sp1
        include_bytes!("sp1/out/uni-evm-sp1-elf")
    }
    #[cfg(not(feature = "sp1"))]
    {
        // Empty slice when SP1 is not enabled
        // This allows the crate to compile without the SP1 toolchain
        &[]
    }
};

/// Path to the verification key file (generated during build)
///
/// This is available for documentation purposes. The actual vkey should be
/// extracted using the `uni-evm extract-vkey` command or by reading this file
/// after building with `--features sp1`.
#[cfg(feature = "sp1")]
pub const VKEY_PATH: &str = "guest-program/src/sp1/out/uni-evm-vkey.bin";

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_elf_availability() {
        #[cfg(feature = "sp1")]
        {
            // With SP1 feature, ELF should be non-empty
            assert!(
                !UNI_EVM_SP1_ELF.is_empty(),
                "SP1 ELF should be included when sp1 feature is enabled"
            );
            assert!(
                UNI_EVM_SP1_ELF.len() > 1024,
                "SP1 ELF should be at least 1KB"
            );
        }

        #[cfg(not(feature = "sp1"))]
        {
            // Without SP1 feature, ELF should be empty
            assert!(
                UNI_EVM_SP1_ELF.is_empty(),
                "SP1 ELF should be empty when sp1 feature is disabled"
            );
        }
    }

    #[test]
    fn test_module_exports() {
        // Verify that all modules are accessible
        use crate::execution::uni_evm_execution;
        use crate::input::UniEvmProgramInput;
        use crate::output::UniEvmProgramOutput;

        // Type assertions
        let _: fn(UniEvmProgramInput) -> Result<UniEvmProgramOutput, _> = uni_evm_execution;
    }
}
